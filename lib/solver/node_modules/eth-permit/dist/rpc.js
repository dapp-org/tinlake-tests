"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.call = exports.getChainId = exports.setChainIdOverride = exports.signData = exports.send = void 0;
const randomId = () => Math.floor(Math.random() * 10000000000);
exports.send = (provider, method, params) => new Promise((resolve, reject) => {
    const payload = {
        id: randomId(),
        method,
        params,
    };
    const callback = (err, result) => {
        if (err) {
            reject(err);
        }
        else if (result.error) {
            console.error(result.error);
            reject(result.error);
        }
        else {
            resolve(result.result);
        }
    };
    let _provider = provider.provider || provider;
    if (_provider.sendAsync) {
        _provider.sendAsync(payload, callback);
    }
    else {
        _provider.send(payload, callback);
    }
});
exports.signData = (provider, fromAddress, typeData) => __awaiter(void 0, void 0, void 0, function* () {
    const typeDataString = typeof typeData === 'string' ? typeData : JSON.stringify(typeData);
    const result = yield exports.send(provider, 'eth_signTypedData_v4', [fromAddress, typeDataString])
        .catch((error) => {
        if (error.message === 'Method eth_signTypedData_v4 not supported.') {
            return exports.send(provider, 'eth_signTypedData', [fromAddress, typeData]);
        }
        else {
            throw error;
        }
    });
    return {
        r: result.slice(0, 66),
        s: '0x' + result.slice(66, 130),
        v: parseInt(result.slice(130, 132), 16),
    };
});
let chainIdOverride = null;
exports.setChainIdOverride = (id) => { chainIdOverride = id; };
exports.getChainId = (provider) => __awaiter(void 0, void 0, void 0, function* () { return chainIdOverride || exports.send(provider, 'eth_chainId'); });
exports.call = (provider, to, data) => exports.send(provider, 'eth_call', [{
        to,
        data,
    }, 'latest']);
